<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Joint Computation and Communication Cooperation for Energy-Efficient Mobile Edge Computing 论文笔记 | 猫崎板子</title>
<link rel="shortcut icon" href="https://www.rayiooo.top/favicon.ico?v=1592645073846">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.rayiooo.top/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Joint Computation and Communication Cooperation for Energy-Efficient Mobile Edge Computing 论文笔记 | 猫崎板子 - Atom Feed" href="https://www.rayiooo.top/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-145147913-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-145147913-2');
</script>


    <meta name="description" content="本文研究了移动边缘计算（MEC）中计算卸载（computation offloading）的优化问题。在边缘网络中如何分配用户的计算任务可以使整体耗电量最小？本文针对 User - Helper - AP 三点式模型求解这个问题的最优解。通..." />
    <meta name="keywords" content="边缘计算,计算卸载,线性规划" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://www.rayiooo.top">
  <img class="avatar" src="https://www.rayiooo.top/images/avatar.png?v=1592645073846" alt="">
  </a>
  <h1 class="site-title">
    猫崎板子
  </h1>
  <p class="site-description">
    いらっしゃいませ
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/rayiooo" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Joint Computation and Communication Cooperation for Energy-Efficient Mobile Edge Computing 论文笔记
            </h2>
            <div class="post-info">
              <span>
                2020-05-05
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://www.rayiooo.top/tag/-oSCsoUR6/" class="post-tag">
                  # 边缘计算
                </a>
              
                <a href="https://www.rayiooo.top/tag/OC5FTxffw1/" class="post-tag">
                  # 计算卸载
                </a>
              
                <a href="https://www.rayiooo.top/tag/a9xVVaYbXl/" class="post-tag">
                  # 线性规划
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://www.rayiooo.top/post-images/joint-computation-and-communication-cooperation-for-energy-efficient-mobile-edge-computing-lun-wen-bi-ji.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>本文研究了移动边缘计算（MEC）中计算卸载（computation offloading）的优化问题。在边缘网络中如何分配用户的计算任务可以使整体耗电量最小？本文针对 User - Helper - AP 三点式模型求解这个问题的最优解。通过构建一个线性规划问题和一个非线性规划问题来分别解可分割任务和不可分割任务的最优耗电量，并使用拉格朗日乘子法和 KKT 条件等方法求出结果，以达到节约设备用电的目的。这篇文章没有什么特别的亮点，仅仅是 LP 问题的一个应用。</p>
<!-- more -->
<h2 id="1-introduction">1 Introduction</h2>
<p>介绍 User - Helper - AP 三点式 MEC 模型。</p>
<h2 id="2-system-model">2 System Model</h2>
<p>构建所提出的模型。</p>
<p>待计算任务的长度为L，分别分配给三点设备。User 自己计算叫本地计算，让 Helper 帮忙叫计算协作，让 AP 帮忙叫通信协作。</p>
<h3 id="2a-时间槽">2.A 时间槽</h3>
<p>该模型共有4段时间槽，对应模型4个阶段。</p>
<h3 id="2b-计算卸载的传输能耗">2.B 计算卸载的传输能耗</h3>
<p>计算卸载就是将 User 自己的任务卸载给别人帮忙计算。</p>
<p>利用<strong>香农定理</strong>，得到了信道传输最大速率，该速率乘以对应时间槽时长就是总传输数据量。由各阶段传输功率和时长，得到传输过程的能耗。</p>
<p>User 传 AP 的过程由 Helper 辅助传输，叫做 DF relay。根据参考文献结论，得到该传输过程总共传输的数据长度。</p>
<h3 id="2c-计算能耗">2.C 计算能耗</h3>
<p>给出了三台设备在此过程中各自的计算能耗。</p>
<p>因为恒频计算优于变频计算，因此计算频率指定为恒定值。</p>
<p>AP处的计算能耗不考虑，因为不 care 它耗多少电，因此它将以最高频率定频运算。</p>
<h2 id="3-problem-formulation">3 Problem Formulation</h2>
<p>该章节构建了一个线性规划问题 P1 和一个非线性规划问题 P2，使得该模型传输的能耗最小（不考虑AP能耗）。P1 对应 partial offloading（可切割问题，可以协作计算），P2 对应 binary loading（不可切割问题，只能一台设备计算）。</p>
<h3 id="3a-可行性分析">3.A 可行性分析</h3>
<p>限定 task 的最大比特长度。</p>
<h2 id="4-optimal-solution-to-p1">4 Optimal Solution to P1</h2>
<p>引入辅助变量 E，消去 P，将 P1 问题转化成 P1.1 问题。</p>
<p>Lemma 1 证明该问题是凸问题。然后用拉格朗日乘子法得到函数 L，进而得到对偶函数 g，让 g 由下往上逼近 L，以此得到 L 的下界。</p>
<p>Lemma 2 的结论保证了 g 不会因消息长度过大而趋向于负无穷，无法从下定界。基于该结论，问题进一步转化为 D1.1。</p>
<p>由于符合 Slater 条件， P1.1 和 D1.1 有强对偶性，因此通过求解 D1.1 来得到最优解。</p>
<h3 id="4a-对偶函数-g-的推导">4.A 对偶函数 g 的推导</h3>
<p>将 L 函数拆分成互不影响的最优化问题问题 (31) - (35)，分别求解即可。不等式约束的最优化问题，构造拉格朗日函数，使用 KKT 条件进行求解，得到 E、τ、l 的最优解。</p>
<p>Remark 1 指明，上述最优解中在某些条件下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>τ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">τ_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">l_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 最优解不是唯一值。我们将两项置为0，以此来评估对偶函数 g。但是这会导致这个解对于问题 P1.1 不可行或非最优，因此在 4.C 中讨论该问题。</p>
<h3 id="4b-计算-λ-μ-最优解来最大化-g">4.B 计算 λ &amp; μ 最优解来最大化 g</h3>
<p>由于对偶函数 g 通常是凹的、不可微的，因此使用基于次梯度的方法（如椭球法）来求解 λ 和 μ 的最优值。具体过程没说，不太懂。</p>
<h3 id="4c-p1-问题的最优原始解">4.C P1 问题的最优原始解</h3>
<p>通过用已求出的各变量最优解带入原来的 P1 或 P1.1 问题，得到新的 LP 问题，用该问题来求解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>τ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">τ_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">l_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最优解。</p>
<p>最后用 Table 1 算法展示了求解 P1 问题的全过程，并根据结果提出一些见解：</p>
<ul>
<li>持续时间 T 变大时，用户更喜欢在 User 本地计算。</li>
<li>信道功率增益 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>01</mn></msub></mrow><annotation encoding="application/x-tex">h_{01}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 变强时，卸载功率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>P</mi><mn>1</mn><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">P_1^{opt1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.198324em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.932016em;"><span style="top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">t</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span> 增加，用户更喜欢将更多任务卸载到 Helper 进行计算协作。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>P</mi><mn>2</mn><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">P_2^{opt1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.198324em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.932016em;"><span style="top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">t</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span> 取决于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>01</mn></msub></mrow><annotation encoding="application/x-tex">h_{01}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>P</mi><mn>3</mn><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">P_3^{opt1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.198324em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.932016em;"><span style="top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">t</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span> 随 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 增加而增加。<br>
通过这些见解可以设计实验。</li>
</ul>
<h2 id="5-optimal-solution-to-p2">5 Optimal Solution to P2</h2>
<p>P2 问题相对简单，因为 binary offloading 只需一台设备计算，只要分别计算三台设备的能耗并进行比较即可。</p>
<h3 id="5a">5.A</h3>
<p><strong>本地计算模式</strong>可直接得出结果。</p>
<p><strong>计算协作模式</strong>（to Helper）是一个单变量优化问题，用二分法即可解得。</p>
<p><strong>通信协作模式</strong>（to AP）是多变量优化，与 P1 问题同法解得。</p>
<h2 id="6-numerical-results">6 Numerical Results</h2>
<p>用对比法对比各种方法效果。分别针对 partial offloading、binary offloading 两种情况，设计本地计算、计算协作、通信协作、三点协作几种方式进行实验。</p>
<p>实验分别研究了时间 T 对任务最大长度的影响、T 对平均能量消耗的影响、任务长度 L 对平均能量消耗的影响、User 到 Helper 距离对平均能量消耗的影响。</p>
<h2 id="7-conclusion">7 Conclusion</h2>
<p>计算与通信三点协作方式最优。</p>
<p>未来仍待解决的问题：</p>
<ul>
<li>尽管只考虑了三点式作业，但可以推广到更一般的情况。但如何有效地将多个 Helper 和 User 配对，以及如何有效设计多用户计算卸载和协作中继仍是困难的问题，需进一步研究。</li>
<li>本文旨在减少总能量消耗，因此采用集中分配。但 Helper 有自身利益，如何采用激励措施激励 Helper 参与计算是一个值得考虑的问题。</li>
</ul>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://blog.csdn.net/qq_34082798/article/details/98106844">MEC笔记-概述</a><br>
[2]<a href="https://zhuanlan.zhihu.com/p/83024975">什么是计算卸载？</a><br>
[3]<a href="https://en.wikipedia.org/wiki/Relay_channel">Relay Channel - WikiPedia</a><br>
[4]<a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92">非线性规划 - WikiPedia</a><br>
[5]<a href="https://blog.csdn.net/xholes/article/details/79899235">凸优化学习：对偶</a><br>
[6]<a href="https://blog.csdn.net/johnnyconstantine/article/details/46335763">KKT条件介绍</a><br>
[7]<a href="https://blog.csdn.net/xiaohukun/article/details/78202351">拉格朗日乘子法（Lagrange Multiplier) 和KKT条件</a><br>
[8]<a href="https://blog.csdn.net/bitcarmanlee/article/details/51896348">次导数 次梯度 小结</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-introduction">1 Introduction</a></li>
<li><a href="#2-system-model">2 System Model</a>
<ul>
<li><a href="#2a-%E6%97%B6%E9%97%B4%E6%A7%BD">2.A 时间槽</a></li>
<li><a href="#2b-%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E7%9A%84%E4%BC%A0%E8%BE%93%E8%83%BD%E8%80%97">2.B 计算卸载的传输能耗</a></li>
<li><a href="#2c-%E8%AE%A1%E7%AE%97%E8%83%BD%E8%80%97">2.C 计算能耗</a></li>
</ul>
</li>
<li><a href="#3-problem-formulation">3 Problem Formulation</a>
<ul>
<li><a href="#3a-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90">3.A 可行性分析</a></li>
</ul>
</li>
<li><a href="#4-optimal-solution-to-p1">4 Optimal Solution to P1</a>
<ul>
<li><a href="#4a-%E5%AF%B9%E5%81%B6%E5%87%BD%E6%95%B0-g-%E7%9A%84%E6%8E%A8%E5%AF%BC">4.A 对偶函数 g 的推导</a></li>
<li><a href="#4b-%E8%AE%A1%E7%AE%97-%CE%BB-%CE%BC-%E6%9C%80%E4%BC%98%E8%A7%A3%E6%9D%A5%E6%9C%80%E5%A4%A7%E5%8C%96-g">4.B 计算 λ &amp; μ 最优解来最大化 g</a></li>
<li><a href="#4c-p1-%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E4%BC%98%E5%8E%9F%E5%A7%8B%E8%A7%A3">4.C P1 问题的最优原始解</a></li>
</ul>
</li>
<li><a href="#5-optimal-solution-to-p2">5 Optimal Solution to P2</a>
<ul>
<li><a href="#5a">5.A</a></li>
</ul>
</li>
<li><a href="#6-numerical-results">6 Numerical Results</a></li>
<li><a href="#7-conclusion">7 Conclusion</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '93abc810d67f36742d48',
    clientSecret: 'a5ba71cfb2c4bbf8eebf28116087a330aa6f21ba',
    repo: 'rayiooo.github.io',
    owner: 'rayiooo',
    admin: ['rayiooo'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://www.rayiooo.top/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
